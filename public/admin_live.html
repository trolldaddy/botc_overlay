<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>BOTC Admin</title>
  <script src="https://extension-files.twitch.tv/helper/v1/twitch-ext.min.js"></script>
  <script src="lz-string.min.js"></script>
  <script src="compression.js"></script>
  <style>
    body { background: #111; color: white; font-family: "Microsoft JhengHei", sans-serif; padding: 20px; }
    label, select, textarea, button { display: block; margin: 10px 0; width: 100%; }
    textarea { height: 200px; font-family: monospace; }
    #customJsonBlock { display: none; }
    #statusMessage { margin-top: 10px; color: #0f0; }
  </style>
</head>
<body>
  <h1>è¨­å®š BOTC Overlay æ“´å……åŠŸèƒ½</h1>
  <label for="scriptList">é¸æ“‡åŠ‡æœ¬ï¼š</label>
  <select id="scriptList"></select>

  <div id="customJsonBlock">
    <label for="customJson">è‡ªè¨‚è§’è‰² JSONï¼š</label>
    <textarea id="customJson" placeholder="è²¼ä¸Šç¬¦åˆ Blood on the Clocktower æ ¼å¼çš„è§’è‰² JSON æ¸…å–®"></textarea>
  </div>

  <button id="saveButton">å„²å­˜è¨­å®š</button>
  <div id="statusMessage"></div>

  <script>
    const scriptListEl = document.getElementById('scriptList');
    const customJsonBlock = document.getElementById('customJsonBlock');
    const customJsonEl = document.getElementById('customJson');
    const saveButton = document.getElementById('saveButton');
    const statusMessage = document.getElementById('statusMessage');

    const MAX_COMPRESSED_CHUNK_SIZE = window.CompressionHelper?.MAX_CHUNK_SIZE || 4500;
    const COMPRESSION_MODE = window.CompressionHelper?.COMPRESSION_MODE || 'lz-string/base64';
    const LEGACY_LZMA_MODE = window.CompressionHelper?.LEGACY_LZMA_MODE || 'lzma/base64';
    const TWITCH_SEGMENT_LIMIT = 4800;
    const MAX_SEGMENT_COUNT = 2;
    const decompressCache = new Map();
    let twitchAuth = { channelId: null, clientId: null, userId: null };
    let latestGlobalChunk = null;

    function computeScriptHash(text) {
      if (!text) {
        return '0';
      }

      let hash = 0;
      for (let i = 0; i < text.length; i += 1) {
        hash = (hash * 31 + text.charCodeAt(i)) >>> 0; // eslint-disable-line no-bitwise
      }
      return hash.toString(16);
    }

    function chunkCompressedText(text) {
      if (!text) {
        return [];
      }

      const chunks = [];
      for (let index = 0; index < text.length; index += MAX_COMPRESSED_CHUNK_SIZE) {
        chunks.push(text.slice(index, index + MAX_COMPRESSED_CHUNK_SIZE));
      }
      return chunks;
    }

    function updateLatestGlobalChunk() {
      const globalContent = window.Twitch?.ext?.configuration?.global?.content;
      if (!globalContent) {
        latestGlobalChunk = null;
        return null;
      }

      try {
        latestGlobalChunk = JSON.parse(globalContent);
      } catch (err) {
        latestGlobalChunk = null;
        console.warn('è§£æ Twitch å…¨åŸŸè¨­å®šå¤±æ•—:', err);
      }

      return latestGlobalChunk;
    }

    async function compressCustomJson(normalizedJson) {
      if (!window.CompressionHelper?.compressToBase64) {
        return null;
      }

      const result = await window.CompressionHelper.compressToBase64(normalizedJson);
      if (!result || typeof result.base64 !== 'string') {
        return null;
      }

      return {
        base64: result.base64,
        mode: result.mode || COMPRESSION_MODE,
        compressedLength: typeof result.compressedLength === 'number'
          ? result.compressedLength
          : result.base64.length,
        compressedByteLength: typeof result.compressedByteLength === 'number'
          ? result.compressedByteLength
          : undefined
      };
    }

    async function decompressBase64(base64, mode = COMPRESSION_MODE) {
      if (!base64) {
        return '';
      }

      const cacheKey = `${mode || 'default'}:${base64}`;

      if (decompressCache.has(cacheKey)) {
        const cached = decompressCache.get(cacheKey);
        return typeof cached === 'string' ? cached : cached;
      }

      const request = window.CompressionHelper?.decompressFromBase64
        ? window.CompressionHelper.decompressFromBase64(base64, mode)
            .then(result => {
              decompressCache.set(cacheKey, result);
              return result;
            })
            .catch(err => {
              decompressCache.delete(cacheKey);
              throw err;
            })
        : Promise.reject(new Error('ç€è¦½å™¨ä¸æ”¯æ´è§£å£“ç¸®åŠŸèƒ½'));

      decompressCache.set(cacheKey, request);
      return request;
    }

    async function reconstructCustomJson(config) {
      if (!config || typeof config !== 'object') {
        return '';
      }

      if (typeof config.customJson === 'string' && config.customJson.trim()) {
        return config.customJson;
      }

      const compressionMode = config.compression || COMPRESSION_MODE;

      if (typeof config.chunk0 === 'string' && config.chunk0.trim()) {
        const chunkCount = typeof config.chunkCount === 'number' ? config.chunkCount : 1;
        let extraChunk = typeof config.extraChunkData === 'string' ? config.extraChunkData : '';

        if (chunkCount > 1 && !extraChunk) {
          const latest = latestGlobalChunk || updateLatestGlobalChunk();
          if (latest
            && latest.id === config.extraChunkId
            && (latest.channelId === undefined
              || !twitchAuth.channelId
              || latest.channelId === twitchAuth.channelId)
            && typeof latest.chunk === 'string') {
            extraChunk = latest.chunk;
          }
        }

        if (chunkCount > 1 && !extraChunk) {
          throw new Error('ç¼ºå°‘è‡ªè¨‚åŠ‡æœ¬çš„é¡å¤–è³‡æ–™å€å¡Š');
        }

        const combined = chunkCount > 1 ? config.chunk0 + extraChunk : config.chunk0;
        return decompressBase64(combined, compressionMode);
      }

      if (typeof config.compressedBase64 === 'string' && config.compressedBase64.trim()) {
        return decompressBase64(config.compressedBase64, compressionMode);
      }

      if (Array.isArray(config.compressedChunks) && config.compressedChunks.length > 0) {
        return decompressBase64(config.compressedChunks.join(''), compressionMode);
      }

      if (Array.isArray(config.customChunks) && config.customChunks.length > 0) {
        return config.customChunks.join('');
      }

      return '';
    }

    async function applyConfig(config) {
      if (!config || typeof config !== 'object') {
        scriptListEl.value = '';
        customJsonEl.value = '';
        customJsonBlock.style.display = 'none';
        return;
      }

      scriptListEl.value = config.selectedScript || '';
      customJsonBlock.style.display = scriptListEl.value === '__custom__' ? 'block' : 'none';

      if (config.selectedScript === '__custom__') {
        try {
          if (config.extraChunkId && !config.extraChunkData) {
            const chunkSource = latestGlobalChunk || updateLatestGlobalChunk();
            if (chunkSource
              && chunkSource.id === config.extraChunkId
              && (chunkSource.channelId === undefined
                || !twitchAuth.channelId
                || chunkSource.channelId === twitchAuth.channelId)
              && typeof chunkSource.chunk === 'string') {
              config.extraChunkData = chunkSource.chunk;
            }
          }

          const json = await reconstructCustomJson(config);
          customJsonEl.value = json || '';
        } catch (err) {
          console.warn('è§£å£“ç¸®è‡ªè¨‚åŠ‡æœ¬å¤±æ•—:', err);
          customJsonEl.value = '';
          statusMessage.textContent = 'âš ï¸ è§£å£“ç¸®è‡ªè¨‚åŠ‡æœ¬å¤±æ•—';
        }
      } else {
        customJsonEl.value = '';
      }
    }

    fetch('Allscript/scripts.json')
      .then(res => res.json())
      .then(scripts => {
        scriptListEl.innerHTML = `<option value="">-- è«‹é¸æ“‡åŠ‡æœ¬ --</option>` +
          scripts.map(f => `<option value="${f}">${f}</option>`).join('') +
          `<option value="__custom__">è‡ªè¨‚åŠ‡æœ¬</option>`;
      })
      .catch(() => {
        statusMessage.textContent = 'âŒ ç„¡æ³•è¼‰å…¥åŠ‡æœ¬æ¸…å–®';
      });

    scriptListEl.addEventListener('change', () => {
      customJsonBlock.style.display = scriptListEl.value === '__custom__' ? 'block' : 'none';
    });

    saveButton.addEventListener('click', async () => {
      const selectedScript = scriptListEl.value;

      if (!selectedScript) {
        statusMessage.textContent = 'âŒ è«‹å…ˆé¸æ“‡åŠ‡æœ¬';
        return;
      }

      if (!window.Twitch?.ext?.configuration) {
        statusMessage.textContent = 'âŒ ç„¡æ³•å­˜å– Twitch Extension API';
        return;
      }

      const timestamp = Date.now();
      let payload = null;
      let storageConfig = null;

      if (selectedScript === '__custom__') {
        const rawJson = customJsonEl.value.trim();
        if (!rawJson) {
          statusMessage.textContent = 'âŒ è«‹è²¼ä¸Šè‡ªè¨‚åŠ‡æœ¬å…§å®¹';
          return;
        }

        let normalized;
        try {
          normalized = JSON.stringify(JSON.parse(rawJson));
        } catch (err) {
          statusMessage.textContent = `âŒ è‡ªè¨‚åŠ‡æœ¬å¿…é ˆæ˜¯æœ‰æ•ˆçš„ JSONï¼š${err.message}`;
          return;
        }

        saveButton.disabled = true;
        statusMessage.textContent = 'ğŸ—œï¸ æ­£åœ¨å£“ç¸®...';

        let compressed = null;
        let segments = [];
        try {
          compressed = await compressCustomJson(normalized);
          if (compressed && typeof compressed.base64 === 'string' && compressed.base64) {
            segments = chunkCompressedText(compressed.base64);
          }
        } catch (err) {
          console.warn('å£“ç¸®è‡ªè¨‚åŠ‡æœ¬å¤±æ•—ï¼Œæ”¹ç”¨æœªå£“ç¸®æ¨¡å¼:', err);
        }

        storageConfig = {
          selectedScript,
          _timestamp: timestamp,
          scriptVersion: timestamp,
          scriptHash: computeScriptHash(normalized),
          customJsonLength: normalized.length
        };

        if (compressed && typeof compressed.base64 === 'string' && segments.length > 0) {
          if (segments.length > MAX_SEGMENT_COUNT) {
            statusMessage.textContent = 'âŒ å£“ç¸®å¾Œä»è¶…é Twitch å…è¨±çš„å¤§å°ï¼Œè«‹åˆªæ¸›å…§å®¹';
            saveButton.disabled = false;
            return;
          }

          storageConfig.compression = compressed.mode || COMPRESSION_MODE;
          storageConfig.compressedLength = compressed.compressedLength || compressed.base64.length;
          storageConfig.compressedByteLength = typeof compressed.compressedByteLength === 'number'
            ? compressed.compressedByteLength
            : (compressed.compressedLength || compressed.base64.length);

          if (segments.length === 1) {
            storageConfig.compressedBase64 = compressed.base64;
          } else {
            if (!twitchAuth.channelId) {
              statusMessage.textContent = 'âŒ éœ€è¦åœ¨ Twitch å¾Œå°æˆæ¬Šå¾Œæ‰èƒ½å„²å­˜å¤§å‹è‡ªè¨‚åŠ‡æœ¬';
              saveButton.disabled = false;
              return;
            }

            storageConfig.chunkCount = segments.length;
            storageConfig.chunk0 = segments[0];
            storageConfig.extraChunkId = `${twitchAuth.channelId}:${timestamp}`;
            storageConfig.extraChunkData = segments[1];
          }
        } else {
          const customChunks = chunkCompressedText(normalized);
          if (customChunks.length > MAX_SEGMENT_COUNT) {
            statusMessage.textContent = 'âŒ è‡ªè¨‚åŠ‡æœ¬éå¤§ä¸”ç„¡æ³•å£“ç¸®ï¼Œè«‹åˆªæ¸›å…§å®¹';
            saveButton.disabled = false;
            return;
          }

          if (customChunks.length <= 1) {
            storageConfig.customJson = normalized;
          } else {
            storageConfig.customChunks = customChunks;
          }

          statusMessage.textContent = 'âš ï¸ ç„¡æ³•ä½¿ç”¨å£“ç¸®ï¼Œæ”¹ç”¨åˆ†æ®µå„²å­˜';
        }

        payload = { ...storageConfig };
        if (payload.extraChunkData) {
          delete payload.extraChunkData;
        }
        if (!payload.customJson) {
          delete payload.customJson;
        }
        if (!payload.customChunks) {
          delete payload.customChunks;
        }
        if (!payload.compressedBase64) {
          delete payload.compressedBase64;
        }
      } else {
        storageConfig = {
          selectedScript,
          _timestamp: timestamp,
          scriptVersion: timestamp
        };
        payload = { ...storageConfig };
      }

      statusMessage.textContent = 'ğŸ’¾ å„²å­˜ä¸­...';

      const requiresGlobal = Boolean(storageConfig?.extraChunkData && storageConfig.extraChunkId);
      let globalPayloadString = null;
      if (requiresGlobal) {
        const globalPayload = {
          id: storageConfig.extraChunkId,
          chunk: storageConfig.extraChunkData,
          compression: storageConfig.compression || COMPRESSION_MODE,
          version: storageConfig.scriptVersion,
          channelId: twitchAuth.channelId || null,
          updatedAt: timestamp
        };
        globalPayloadString = JSON.stringify(globalPayload);

        if (globalPayloadString.length > TWITCH_SEGMENT_LIMIT) {
          statusMessage.textContent = 'âŒ åˆ†æ®µè³‡æ–™ä»è¶…é 5KB é™åˆ¶ï¼Œè«‹åˆªæ¸›åŠ‡æœ¬å…§å®¹';
          saveButton.disabled = false;
          return;
        }
      } else {
        const clearedPayload = {
          id: '',
          chunk: '',
          channelId: twitchAuth.channelId || null,
          clearedAt: timestamp
        };
        globalPayloadString = JSON.stringify(clearedPayload);
      }

      const payloadString = JSON.stringify(payload);
      if (payloadString.length > TWITCH_SEGMENT_LIMIT) {
        statusMessage.textContent = 'âŒ å„²å­˜å…§å®¹è¶…é 5KB é™åˆ¶ï¼Œè«‹åˆªæ¸›åŠ‡æœ¬æˆ–ç¸®çŸ­æè¿°';
        saveButton.disabled = false;
        return;
      }

      try {
        if (globalPayloadString) {
          window.Twitch.ext.configuration.set('global', '1', globalPayloadString);
        }

        window.Twitch.ext.configuration.set('broadcaster', '1', payloadString);
        if (window.Twitch.ext.send) {
          try {
            window.Twitch.ext.send('broadcast', 'application/json', payloadString);
          } catch (err) {
            console.warn('é€é Twitch å»£æ’­æ›´æ–°è¨­å®šæ™‚ç™¼ç”ŸéŒ¯èª¤:', err);
          }
        }
        statusMessage.textContent = 'âœ… è¨­å®šå·²å„²å­˜ï¼è«‹åˆ‡æ› Overlay æ¸¬è©¦çµæœ';
      } catch (err) {
        console.error('å„²å­˜ Twitch è¨­å®šå¤±æ•—:', err);
        statusMessage.textContent = 'âŒ å„²å­˜è¨­å®šå¤±æ•—';
      } finally {
        saveButton.disabled = false;
      }
    });

    if (window.Twitch?.ext) {
      window.Twitch.ext.onAuthorized(async auth => {
        twitchAuth = {
          channelId: auth?.channelId || null,
          clientId: auth?.clientId || null,
          userId: auth?.userId || null
        };
        updateLatestGlobalChunk();
        const configStr = window.Twitch.ext.configuration?.broadcaster?.content;
        if (configStr) {
          try {
            const config = JSON.parse(configStr || '{}');
            await applyConfig(config);
          } catch (err) {
            console.warn('è§£æ Twitch è¨­å®šå¤±æ•—:', err);
          }
        }
      });

      window.Twitch.ext.configuration.onChanged(async () => {
        updateLatestGlobalChunk();
        const configStr = window.Twitch.ext.configuration.broadcaster?.content;
        if (!configStr) {
          await applyConfig({});
          return;
        }

        try {
          const config = JSON.parse(configStr || '{}');
          await applyConfig(config);
        } catch (err) {
          console.warn('è§£æ Twitch è¨­å®šå¤±æ•—:', err);
        }
      });
    }
  </script>
</body>
</html>
