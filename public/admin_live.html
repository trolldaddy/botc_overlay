<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>BOTC Admin</title>
  <script src="https://extension-files.twitch.tv/helper/v1/twitch-ext.min.js"></script>
  <script src="compression.js"></script>
  <style>
    body { background: #111; color: white; font-family: "Microsoft JhengHei", sans-serif; padding: 20px; }
    label, select, textarea, button { display: block; margin: 10px 0; width: 100%; }
    textarea { height: 200px; font-family: monospace; }
    #customJsonBlock { display: none; }
    #statusMessage { margin-top: 10px; color: #0f0; }
  </style>
</head>
<body>
  <h1>設定 BOTC Overlay 擴充功能</h1>
  <label for="scriptList">選擇劇本：</label>
  <select id="scriptList"></select>

  <div id="customJsonBlock">
    <label for="customJson">自訂角色 JSON：</label>
    <textarea id="customJson" placeholder="貼上符合 Blood on the Clocktower 格式的角色 JSON 清單"></textarea>
  </div>

  <button id="saveButton">儲存設定</button>
  <div id="statusMessage"></div>

  <script>
    const scriptListEl = document.getElementById('scriptList');
    const customJsonBlock = document.getElementById('customJsonBlock');
    const customJsonEl = document.getElementById('customJson');
    const saveButton = document.getElementById('saveButton');
    const statusMessage = document.getElementById('statusMessage');

    const MAX_COMPRESSED_CHUNK_SIZE = window.CompressionHelper?.MAX_CHUNK_SIZE || 4800;
    const COMPRESSION_MODE = window.CompressionHelper?.COMPRESSION_MODE || 'gzip/base64';
    const decompressCache = new Map();

    function computeScriptHash(text) {
      if (!text) {
        return '0';
      }

      let hash = 0;
      for (let i = 0; i < text.length; i += 1) {
        hash = (hash * 31 + text.charCodeAt(i)) >>> 0; // eslint-disable-line no-bitwise
      }
      return hash.toString(16);
    }

    function chunkCompressedText(text) {
      if (!text) {
        return [];
      }

      const chunks = [];
      for (let index = 0; index < text.length; index += MAX_COMPRESSED_CHUNK_SIZE) {
        chunks.push(text.slice(index, index + MAX_COMPRESSED_CHUNK_SIZE));
      }
      return chunks;
    }

    async function compressCustomJson(normalizedJson) {
      if (!window.CompressionHelper?.compressToBase64) {
        return null;
      }

      const result = await window.CompressionHelper.compressToBase64(normalizedJson);
      if (!result || typeof result.base64 !== 'string') {
        return null;
      }

      return {
        base64: result.base64,
        compressedLength: typeof result.compressedLength === 'number'
          ? result.compressedLength
          : result.base64.length
      };
    }

    async function decompressBase64(base64) {
      if (!base64) {
        return '';
      }

      if (decompressCache.has(base64)) {
        const cached = decompressCache.get(base64);
        return typeof cached === 'string' ? cached : cached;
      }

      const request = window.CompressionHelper?.decompressFromBase64
        ? window.CompressionHelper.decompressFromBase64(base64)
            .then(result => {
              decompressCache.set(base64, result);
              return result;
            })
            .catch(err => {
              decompressCache.delete(base64);
              throw err;
            })
        : Promise.reject(new Error('瀏覽器不支援解壓縮功能'));

      decompressCache.set(base64, request);
      return request;
    }

    async function reconstructCustomJson(config) {
      if (!config || typeof config !== 'object') {
        return '';
      }

      if (typeof config.customJson === 'string' && config.customJson.trim()) {
        return config.customJson;
      }

      if (typeof config.compressedBase64 === 'string' && config.compressedBase64.trim()) {
        return decompressBase64(config.compressedBase64);
      }

      if (Array.isArray(config.compressedChunks) && config.compressedChunks.length > 0) {
        return decompressBase64(config.compressedChunks.join(''));
      }

      if (Array.isArray(config.customChunks) && config.customChunks.length > 0) {
        return config.customChunks.join('');
      }

      return '';
    }

    async function applyConfig(config) {
      if (!config || typeof config !== 'object') {
        scriptListEl.value = '';
        customJsonEl.value = '';
        customJsonBlock.style.display = 'none';
        return;
      }

      scriptListEl.value = config.selectedScript || '';
      customJsonBlock.style.display = scriptListEl.value === '__custom__' ? 'block' : 'none';

      if (config.selectedScript === '__custom__') {
        try {
          const json = await reconstructCustomJson(config);
          customJsonEl.value = json || '';
        } catch (err) {
          console.warn('解壓縮自訂劇本失敗:', err);
          customJsonEl.value = '';
          statusMessage.textContent = '⚠️ 解壓縮自訂劇本失敗';
        }
      } else {
        customJsonEl.value = '';
      }
    }

    fetch('Allscript/scripts.json')
      .then(res => res.json())
      .then(scripts => {
        scriptListEl.innerHTML = `<option value="">-- 請選擇劇本 --</option>` +
          scripts.map(f => `<option value="${f}">${f}</option>`).join('') +
          `<option value="__custom__">自訂劇本</option>`;
      })
      .catch(() => {
        statusMessage.textContent = '❌ 無法載入劇本清單';
      });

    scriptListEl.addEventListener('change', () => {
      customJsonBlock.style.display = scriptListEl.value === '__custom__' ? 'block' : 'none';
    });

    saveButton.addEventListener('click', async () => {
      const selectedScript = scriptListEl.value;

      if (!selectedScript) {
        statusMessage.textContent = '❌ 請先選擇劇本';
        return;
      }

      if (!window.Twitch?.ext?.configuration) {
        statusMessage.textContent = '❌ 無法存取 Twitch Extension API';
        return;
      }

      const timestamp = Date.now();
      let payload;

      if (selectedScript === '__custom__') {
        const rawJson = customJsonEl.value.trim();
        if (!rawJson) {
          statusMessage.textContent = '❌ 請貼上自訂劇本內容';
          return;
        }

        let normalized;
        try {
          normalized = JSON.stringify(JSON.parse(rawJson), null, 2);
        } catch (err) {
          statusMessage.textContent = `❌ 自訂劇本必須是有效的 JSON：${err.message}`;
          return;
        }

        saveButton.disabled = true;
        statusMessage.textContent = '🗜️ 正在壓縮...';

        let usedCompression = false;
        let compressed = null;
        try {
          compressed = await compressCustomJson(normalized);
          if (compressed && typeof compressed.base64 === 'string' && compressed.base64) {
            const chunks = chunkCompressedText(compressed.base64);
            if (chunks.length > 0) {
              const basePayload = {
                selectedScript,
                _timestamp: timestamp,
                scriptVersion: timestamp,
                scriptHash: computeScriptHash(normalized),
                customJsonLength: normalized.length,
                compression: COMPRESSION_MODE,
                compressedLength: compressed.compressedLength || compressed.base64.length
              };

              payload = chunks.length <= 1
                ? { ...basePayload, compressedBase64: compressed.base64 }
                : { ...basePayload, compressedChunks: chunks };

              usedCompression = true;
            }
          }
        } catch (err) {
          console.warn('壓縮自訂劇本失敗，改用未壓縮模式:', err);
        }

        if (!usedCompression) {
          const basePayload = {
            selectedScript,
            _timestamp: timestamp,
            scriptVersion: timestamp,
            scriptHash: computeScriptHash(normalized),
            customJsonLength: normalized.length
          };

          const customChunks = chunkCompressedText(normalized);
          if (customChunks.length <= 1) {
            payload = { ...basePayload, customJson: normalized };
          } else {
            payload = { ...basePayload, customChunks };
          }

          statusMessage.textContent = '⚠️ 無法使用壓縮，改用分段儲存';
        }
      } else {
        payload = {
          selectedScript,
          _timestamp: timestamp,
          scriptVersion: timestamp
        };
      }

      statusMessage.textContent = '💾 儲存中...';

      const payloadString = JSON.stringify(payload);
      try {
        window.Twitch.ext.configuration.set('broadcaster', '1', payloadString);
        if (window.Twitch.ext.send) {
          try {
            window.Twitch.ext.send('broadcast', 'application/json', payloadString);
          } catch (err) {
            console.warn('透過 Twitch 廣播更新設定時發生錯誤:', err);
          }
        }
        statusMessage.textContent = '✅ 設定已儲存！請切換 Overlay 測試結果';
      } catch (err) {
        console.error('儲存 Twitch 設定失敗:', err);
        statusMessage.textContent = '❌ 儲存設定失敗';
      } finally {
        saveButton.disabled = false;
      }
    });

    if (window.Twitch?.ext) {
      window.Twitch.ext.configuration.onChanged(async () => {
        const configStr = window.Twitch.ext.configuration.broadcaster?.content;
        try {
          const config = JSON.parse(configStr || '{}');
          await applyConfig(config);
        } catch (err) {
          console.warn('解析 Twitch 設定失敗:', err);
        }
      });
    }
  </script>
</body>
</html>
